<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sky3D: inout Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sky3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceinout.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">inout Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This module contains the procedures for binary input and output of the larger fields.  
<a href="namespaceinout.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a9d5fd84daf7280d1429a1cc639a77e1b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinout.html#a9d5fd84daf7280d1429a1cc639a77e1b">write_wavefunctions</a></td></tr>
<tr class="memdesc:a9d5fd84daf7280d1429a1cc639a77e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine writes the wave functions to the disk and has two modes of operation depending on whether the code runs on distributed-memory systems in <code>MPI</code> mode or on a shared-memory or single-processor machine.  <a href="namespaceinout.html#a9d5fd84daf7280d1429a1cc639a77e1b">More...</a><br /></td></tr>
<tr class="separator:a9d5fd84daf7280d1429a1cc639a77e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106b9c386384f988c48ef5ac7780283e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinout.html#a106b9c386384f988c48ef5ac7780283e">write_densities</a></td></tr>
<tr class="memdesc:a106b9c386384f988c48ef5ac7780283e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine produces a file <code>iter.tdd</code> with density and current data for the present time step or iteration with number <code>iter</code>. In the file name <code>iter</code> is given in 6 decimal digits.  <a href="namespaceinout.html#a106b9c386384f988c48ef5ac7780283e">More...</a><br /></td></tr>
<tr class="separator:a106b9c386384f988c48ef5ac7780283e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30aedba153613f9688e3911420485cdd"><td class="memItemLeft" align="right" valign="top">subroutine, private&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinout.html#a30aedba153613f9688e3911420485cdd">write_one_density</a> (name, values)</td></tr>
<tr class="memdesc:a30aedba153613f9688e3911420485cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutines does the actual output for <code>write_densities</code> in the case of a scalar field. Its functioning should be clear from the description above.  <a href="namespaceinout.html#a30aedba153613f9688e3911420485cdd">More...</a><br /></td></tr>
<tr class="separator:a30aedba153613f9688e3911420485cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e01e6139174c3213653d9d426393be"><td class="memItemLeft" align="right" valign="top">subroutine, private&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinout.html#ae5e01e6139174c3213653d9d426393be">write_vec_density</a> (name, values)</td></tr>
<tr class="memdesc:ae5e01e6139174c3213653d9d426393be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This also does the actual output for subroutines <code>write_densities</code> for the case of a vector field. Its functioning should be clear from the description above.  <a href="namespaceinout.html#ae5e01e6139174c3213653d9d426393be">More...</a><br /></td></tr>
<tr class="separator:ae5e01e6139174c3213653d9d426393be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674610dcc3ea10a3bacbc06cf120c257"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinout.html#a674610dcc3ea10a3bacbc06cf120c257">plot_density</a></td></tr>
<tr class="memdesc:a674610dcc3ea10a3bacbc06cf120c257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a simple printer plot of the density distribution in the reaction plane. This is not supposed to replace better plotting codes, but simply allows a quick glance at what is happening in the code, even while it is running.  <a href="namespaceinout.html#a674610dcc3ea10a3bacbc06cf120c257">More...</a><br /></td></tr>
<tr class="separator:a674610dcc3ea10a3bacbc06cf120c257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12702257d10a7c3db099de11a2a7eb78"><td class="memItemLeft" align="right" valign="top">pure real(db) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinout.html#a12702257d10a7c3db099de11a2a7eb78">bplina</a> (n, m, xar, zar, fun, xcu, zcu)</td></tr>
<tr class="memdesc:a12702257d10a7c3db099de11a2a7eb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a bilinear interpolation of fun(nx,nz), on xar(n) and zar(m)  <a href="namespaceinout.html#a12702257d10a7c3db099de11a2a7eb78">More...</a><br /></td></tr>
<tr class="separator:a12702257d10a7c3db099de11a2a7eb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a96b0fa1f4abbf1b4a2da1b9064af9f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinout.html#a9a96b0fa1f4abbf1b4a2da1b9064af9f">sp_properties</a></td></tr>
<tr class="memdesc:a9a96b0fa1f4abbf1b4a2da1b9064af9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this routine the kinetic energy, orbital and spin angular momenta expectation values, <code>sp_kinetic</code>, <code>sp_orbital}</code> and <code>sp_spin</code> of the single-particle states are calculated. The latter are both three-dimensional vectors.  <a href="namespaceinout.html#a9a96b0fa1f4abbf1b4a2da1b9064af9f">More...</a><br /></td></tr>
<tr class="separator:a9a96b0fa1f4abbf1b4a2da1b9064af9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b3c7249f196c6a18b17f073ffc4b21"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinout.html#a66b3c7249f196c6a18b17f073ffc4b21">start_protocol</a> (filename, header)</td></tr>
<tr class="memdesc:a66b3c7249f196c6a18b17f073ffc4b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is given a file name and a character string for a header line to start the file contents. It is used for the <code>*.res</code> files. If the file already exists, nothing is done, since this probably a restart job and output should just be added at the end of the file.  <a href="namespaceinout.html#a66b3c7249f196c6a18b17f073ffc4b21">More...</a><br /></td></tr>
<tr class="separator:a66b3c7249f196c6a18b17f073ffc4b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This module contains the procedures for binary input and output of the larger fields. </p>
<p>There are two variants, both of which are written at regular intervals: the wave function file <code>wffile</code> and the files containing the densities and currents. Since the former is extremely space-consuming, each output normally overwrites the previous one. These files are intended to be used for a restart, as initialization input (static solution for one fragment) for another run, or for a final analysis of the wave functions.</p>
<p>The densities, on the other hand, are written on a series of file <code> nnnnnn.tdd</code>, where <code>nnnnnn</code> is the number of the time step or iteration. This is useful for later graphical or other types of analysis.</p>
<p><b>Note:</b> where the variable name <code>wffile</code> is used inside file names in the following, it should not be taken literally but is replaced by the character string it contains.</p>
<p>In addition the routine for printer plots, <code>plot_density</code>, is included in this module, as well as the subroutines <code>sp_properties</code> and <code>start_protocol</code>, which do not completely match the purpose of this module but are placed here for convenience. </p>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="a12702257d10a7c3db099de11a2a7eb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12702257d10a7c3db099de11a2a7eb78">&#9670;&nbsp;</a></span>bplina()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure real(db) function inout::bplina </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(db), dimension(n), intent(in)&#160;</td>
          <td class="paramname"><em>xar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(db), dimension(m), intent(in)&#160;</td>
          <td class="paramname"><em>zar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(db), dimension(n,m), intent(in)&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(db), intent(in)&#160;</td>
          <td class="paramname"><em>xcu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(db), intent(in)&#160;</td>
          <td class="paramname"><em>zcu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does a bilinear interpolation of fun(nx,nz), on xar(n) and zar(m) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>INTEGER, takes the number of grid points in x-direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>INTEGER, takes the number of grid points in z-direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xar</td><td>REAL(db), array, takes coordinates in x direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zar</td><td>REAL(db), array, takes coordinates in z direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>REAL(db), array, takes the function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xcu</td><td>REAL(db), takes the x-value at which the interpolation is performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zcu</td><td>REAL(db), takes the z-value at which the interpolation is performed <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a674610dcc3ea10a3bacbc06cf120c257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674610dcc3ea10a3bacbc06cf120c257">&#9670;&nbsp;</a></span>plot_density()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine inout::plot_density</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produces a simple printer plot of the density distribution in the reaction plane. This is not supposed to replace better plotting codes, but simply allows a quick glance at what is happening in the code, even while it is running. </p>
<p>It is based on a very old routine found at ORNL and was translated into modern Fortran. It uses helper function <code>bplina</code> for interpolation. <br  />
 </p>

</div>
</div>
<a id="a9a96b0fa1f4abbf1b4a2da1b9064af9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a96b0fa1f4abbf1b4a2da1b9064af9f">&#9670;&nbsp;</a></span>sp_properties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine inout::sp_properties</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In this routine the kinetic energy, orbital and spin angular momenta expectation values, <code>sp_kinetic</code>, <code>sp_orbital}</code> and <code>sp_spin</code> of the single-particle states are calculated. The latter are both three-dimensional vectors. </p>
<p>Note that the single-particle energy <code>sp_energy</code> itself is not calculated here but in the main static and dynamic routines, since it is obtained by applying the single-particle Hamiltonian, which is done more conveniently there.</p>
<p>The procedure is quite simple: in a loop over wave functions the active one is copied into <code>pst</code> for convenience. Then its three directional derivatives <code>psx</code>, <code>psy</code>, and <code>psz</code> and Laplacian <code>psw</code> are calculated. In the big loop over the grid they are combined to the desired matrix elements; the only technical point to remark is that since the result must be real, efficiency can be achieved by formulating the complex products in an explicit way. Then <code>kin</code> contains the kinetic energy (without the <img class="formulaInl" alt="$ \hbar^2/2m $" src="form_41.png"/>), <code>cc</code> the orbital and <code>ss</code> then spin matrix elements.</p>
<p>Finally only the volume element, the factor of one half for the spin ad the prefactor of the kinetic energy are added. </p>

</div>
</div>
<a id="a66b3c7249f196c6a18b17f073ffc4b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b3c7249f196c6a18b17f073ffc4b21">&#9670;&nbsp;</a></span>start_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine inout::start_protocol </td>
          <td>(</td>
          <td class="paramtype">character(*), intent(in)&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(*), intent(in)&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is given a file name and a character string for a header line to start the file contents. It is used for the <code>*.res</code> files. If the file already exists, nothing is done, since this probably a restart job and output should just be added at the end of the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>CHARACTER, array, takes the filename. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>CHARACTER, array, takes the intended header for the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a106b9c386384f988c48ef5ac7780283e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106b9c386384f988c48ef5ac7780283e">&#9670;&nbsp;</a></span>write_densities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine inout::write_densities</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This subroutine produces a file <code>iter.tdd</code> with density and current data for the present time step or iteration with number <code>iter</code>. In the file name <code>iter</code> is given in 6 decimal digits. </p>
<p>The record structure is as follows:</p>
<ul>
<li><em>Record 1:</em> this contains the variables <code> iter, time, nx, ny, and nz to define the dimensions of the fields.</code></li>
<li><em>Record 2:</em> contains the variables <code> dx, dy, dz, wxyz, x, y, and z </code> to allow proper labelling of axes in plots, etc.</li>
<li><em>Further records:</em> for each field to be written, a record is produced with the following information:<ol type="1">
<li>Name of the field with up to 10 characters</li>
<li>Logical value <code>scalar</code> to indicate whether it is a scalar (<code></code>.FALSE.) or a vector field (<code></code>.TRUE.).</li>
<li>Logical value <code>write_isospin</code> to indicate whether the field is summed over protons and neutrons ((<code></code>.FALSE. or not (<code></code>.TRUE.). In the latter case the field has a last index running from 1 to 2 for neutrons and protons, respectively. <b> This selection applies to all fields equally (except the Coulomb potential)</b>.</li>
</ol>
</li>
</ul>
<p>After this identification record, the corresponding field itself is written. The dimension varies in the following way: </p><a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>Dimensions of arrays</caption>
<tr>
<th>scalar</th><th>write_isospin</th><th>dimension </th></tr>
<tr>
<td>.FALSE.</td><td>.FALSE.</td><td>(nx,ny,nz) </td></tr>
<tr>
<td>.FALSE.</td><td>.TRUE.</td><td>(nx,ny,nz,2) </td></tr>
<tr>
<td>.TRUE.</td><td>.FALSE.</td><td>(nx,ny,nz,3) </td></tr>
<tr>
<td>.TRUE.</td><td>.TRUE.</td><td>(nx,ny,nz,3,2) </td></tr>
</table>
<p>The <b> selection of fields to be output </b> is handled through variable <code>writeselect</code> consisting of <code>nselect</code> characters. Each field is selected by a one-character code, where both lower and upper case are acceptable. At present the choices are: -<b>R</b>: density <code>rho</code> (scalar). Name <code>Rho</code>. -<b>T</b>: kinetic energy density <code>tau</code> (scalar). Name <code>Tau</code> -<b>U</b>: local mean field <code>upot</code>. Name <code>Upot</code>. -<b>W</b>: Coulomb potential <code>wcoul</code> (scalar). This has to be handled specially, since it has no isospin index. Name <code>Wcoul</code>. -<b>C</b>: current density <code>current</code> (vector). Name <code>Current</code>. -<b>S</b>: spin density <code>sdens</code> (vector). Name <code>Spindens</code>. -<b>O</b>: spin-orbit density <code>sodens</code>. Name <code>s-o-Dens</code>.</p>
<p>This system is set up to be easily modified for writing additional fields. </p>

</div>
</div>
<a id="a30aedba153613f9688e3911420485cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30aedba153613f9688e3911420485cdd">&#9670;&nbsp;</a></span>write_one_density()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, private inout::write_one_density </td>
          <td>(</td>
          <td class="paramtype">character(*), intent(in)&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(db), dimension(nx,ny,nz,2), intent(in)&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This subroutines does the actual output for <code>write_densities</code> in the case of a scalar field. Its functioning should be clear from the description above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>INTEGER, takes the name of the density. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>REAL(db), takes the density. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5e01e6139174c3213653d9d426393be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e01e6139174c3213653d9d426393be">&#9670;&nbsp;</a></span>write_vec_density()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, private inout::write_vec_density </td>
          <td>(</td>
          <td class="paramtype">character(*), intent(in)&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(db), dimension(nx,ny,nz,3,2), intent(in)&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This also does the actual output for subroutines <code>write_densities</code> for the case of a vector field. Its functioning should be clear from the description above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>INTEGER, takes the name of the density. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>REAL(db), takes the vector density. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d5fd84daf7280d1429a1cc639a77e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5fd84daf7280d1429a1cc639a77e1b">&#9670;&nbsp;</a></span>write_wavefunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine inout::write_wavefunctions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This subroutine writes the wave functions to the disk and has two modes of operation depending on whether the code runs on distributed-memory systems in <code>MPI</code> mode or on a shared-memory or single-processor machine. </p>
<p>In both cases it first determines the number of filled single-particle states <code> number(iq)</code>, which need not be the same as either the number of particles or the number of states, since pairing may lead to partial occupation and in addition there can be empty states.</p>
<ul>
<li><b> Sequential operation:</b> this case is recognized recognized by <code> mpi_nprocs==1</code>. Open <code>wffile</code>, then write four records containing general information.<ul>
<li><em>Record 1:</em> <code> iter, nstmax, nneut, nprot, number, npsi, charge_number, mass_number, cm.</code></li>
<li><em>Record 2:</em> <code> nx, ny, nz, dx, dy, dz, wxyz.</code></li>
<li><em>Record 3:</em> <code> x, y, z.</code></li>
<li><em>Record 4:</em> <code> wocc, sp_energy, sp_parity, sp_norm, sp_kinetic, sp_efluct1.</code></li>
</ul>
</li>
</ul>
<p>These are followed by one record containing information for the <code>MPI</code> case, which is included here only for compatibility: <code>node</code>, <code>localindex</code>. This is then followed by a series of <code>nstloc</code> records (in the sequential case, <code>nstloc</code> equals <code>nstmax</code>), containing the array of <code> nx*ny*nz*2</code> wave function values for each single-particle state (including spin).</p>
<ul>
<li><p class="startli"><b> MPI operation:</b> in this case processor #0 writes the same general data as in the sequential case onto file <code>wffile</code>, which is then closed. The purpose of record 5 in this case is to record for each wave function (in global index space) which node it is in and what the index on that node is. Since each node produces a separate output file with only its wave functions, this allows reading any wave function correctly from the set of files.</p>
<p class="startli">Each processor thus only writes the wave function data for its locally stored set of <code>nstloc</code> wave functions onto files with the names composed (in variable <code>rsf}</code>) of the number of the processor and <code>wffile</code> in the form <code>nnn.wffile</code>. For example, if <code>wffile</code> has the value 'Ca40', these files will be <code>000.Ca40</code>, <code>001.Ca40</code>, <code>002.Ca40</code>, etc. up to the number of processors. </p>
</li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceinout.html">inout</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
