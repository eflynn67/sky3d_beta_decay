<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sky3D: static Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sky3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacestatic.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">static Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This module contains the routines needed for the static iterations. All the logic needed for this case is concentrated here; all other modules except for <code>External</code> are equally used in the dynamic calculation.  
<a href="namespacestatic.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a0819e22b12fb490f7e3d309592b6b6b7"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a0819e22b12fb490f7e3d309592b6b6b7">getin_static</a></td></tr>
<tr class="memdesc:a0819e22b12fb490f7e3d309592b6b6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine reads the input for the static calculation using namelist <code>static</code>.  <a href="namespacestatic.html#a0819e22b12fb490f7e3d309592b6b6b7">More...</a><br /></td></tr>
<tr class="separator:a0819e22b12fb490f7e3d309592b6b6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa74b74b5f0d14e753aea12e1f5a3015"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#afa74b74b5f0d14e753aea12e1f5a3015">init_static</a></td></tr>
<tr class="memdesc:afa74b74b5f0d14e753aea12e1f5a3015"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine essentially just prints the static input and then initializes the header files with their header lines.  <a href="namespacestatic.html#afa74b74b5f0d14e753aea12e1f5a3015">More...</a><br /></td></tr>
<tr class="separator:afa74b74b5f0d14e753aea12e1f5a3015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6429b3a218b0e96282940fa9f8573cff"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a6429b3a218b0e96282940fa9f8573cff">statichf</a></td></tr>
<tr class="memdesc:a6429b3a218b0e96282940fa9f8573cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the principal routine for the static iterations. It applies the gradient step repeatedly until convergence is achieved or the maximum number of iterations is reached.  <a href="namespacestatic.html#a6429b3a218b0e96282940fa9f8573cff">More...</a><br /></td></tr>
<tr class="separator:a6429b3a218b0e96282940fa9f8573cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac009061bd66f4ecd0ecedfc3195ef394"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#ac009061bd66f4ecd0ecedfc3195ef394">grstep</a> (nst, iq, spe, denerg, psin)</td></tr>
<tr class="memdesc:ac009061bd66f4ecd0ecedfc3195ef394"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine applies the damped gradient step to a wave function <code>psi</code>. Its index is <code>nst</code> and isospin <code>iq</code> - these data are needed for the construction of the Hamiltonian matrix <code>hmatr</code>. The argument <code>spe</code> <img class="formulaInl" alt="$ \rightarrow\epsilon $" src="form_215.png"/> represents the single-particle energy which is used a an energy shift in the calculation.  <a href="namespacestatic.html#ac009061bd66f4ecd0ecedfc3195ef394">More...</a><br /></td></tr>
<tr class="separator:ac009061bd66f4ecd0ecedfc3195ef394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc2fc5ec7d1e7932a73664556b37785"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a8fc2fc5ec7d1e7932a73664556b37785">diagstep</a> (iq, nlin)</td></tr>
<tr class="memdesc:a8fc2fc5ec7d1e7932a73664556b37785"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine performs a diagonalization of the single-particle Hamiltonian using the LAPACK routine <code>ZHEEVD</code>. This is of course done separately for protons and neutrons indexed by <code>iq</code>. The matrix <code>hmatr</code> is produced in <code>grstep</code>.  <a href="namespacestatic.html#a8fc2fc5ec7d1e7932a73664556b37785">More...</a><br /></td></tr>
<tr class="separator:a8fc2fc5ec7d1e7932a73664556b37785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4414bd66d5a02faadc9bca95de6630e6"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a4414bd66d5a02faadc9bca95de6630e6">sinfo</a></td></tr>
<tr class="memdesc:a4414bd66d5a02faadc9bca95de6630e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine computes the data that are not needed for the calculation itself, but only for informative output and writes them onto the appropriate output files.  <a href="namespacestatic.html#a4414bd66d5a02faadc9bca95de6630e6">More...</a><br /></td></tr>
<tr class="separator:a4414bd66d5a02faadc9bca95de6630e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567e41f470e7ceb65e1820519b13bf5f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a567e41f470e7ceb65e1820519b13bf5f">harmosc</a></td></tr>
<tr class="memdesc:a567e41f470e7ceb65e1820519b13bf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subroutine initializes all wave function with harmonic oscillator states.  <a href="namespacestatic.html#a567e41f470e7ceb65e1820519b13bf5f">More...</a><br /></td></tr>
<tr class="separator:a567e41f470e7ceb65e1820519b13bf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a02053607d91051521724b6d73caa35e4"><td class="memItemLeft" align="right" valign="top">logical&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a02053607d91051521724b6d73caa35e4">tdiag</a> =.FALSE.</td></tr>
<tr class="memdesc:a02053607d91051521724b6d73caa35e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>true</code>, there is a diagonalization of the Hamiltonian during the later (after the 20th) static iterations. The 20 is hard coded in <code><a class="el" href="static_8f90.html">static.f90</a></code>.  <a href="namespacestatic.html#a02053607d91051521724b6d73caa35e4">More...</a><br /></td></tr>
<tr class="separator:a02053607d91051521724b6d73caa35e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48d61c855e561751a112a5d392a728d"><td class="memItemLeft" align="right" valign="top">logical&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#ae48d61c855e561751a112a5d392a728d">tlarge</a> =.FALSE.</td></tr>
<tr class="memdesc:ae48d61c855e561751a112a5d392a728d"><td class="mdescLeft">&#160;</td><td class="mdescRight">if <code>true</code>, during the diagonalization the new wave functions are temporarily written on disk to avoid  <a href="namespacestatic.html#ae48d61c855e561751a112a5d392a728d">More...</a><br /></td></tr>
<tr class="separator:ae48d61c855e561751a112a5d392a728d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0a2ff8e5c6872e60c3ed0dfbed39c4"><td class="memItemLeft" align="right" valign="top">logical&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a0b0a2ff8e5c6872e60c3ed0dfbed39c4">tvaryx_0</a> =.FALSE.</td></tr>
<tr class="memdesc:a0b0a2ff8e5c6872e60c3ed0dfbed39c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">it <code>.TRUE.</code> the parameter <img class="formulaInl" alt="$ x_0 $" src="form_214.png"/> is changed in every iteration in order to achieve faster convergence.  <a href="namespacestatic.html#a0b0a2ff8e5c6872e60c3ed0dfbed39c4">More...</a><br /></td></tr>
<tr class="separator:a0b0a2ff8e5c6872e60c3ed0dfbed39c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a40f66c0ff0224e36ec56c3ac25e492"><td class="memItemLeft" align="right" valign="top">integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a0a40f66c0ff0224e36ec56c3ac25e492">maxiter</a></td></tr>
<tr class="memdesc:a0a40f66c0ff0224e36ec56c3ac25e492"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of iterations allowed.  <a href="namespacestatic.html#a0a40f66c0ff0224e36ec56c3ac25e492">More...</a><br /></td></tr>
<tr class="separator:a0a40f66c0ff0224e36ec56c3ac25e492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30ae4cf1ce4900bd6dc12ebb31b2d5b"><td class="memItemLeft" align="right" valign="top">real(db)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#ad30ae4cf1ce4900bd6dc12ebb31b2d5b">radinx</a></td></tr>
<tr class="memdesc:ad30ae4cf1ce4900bd6dc12ebb31b2d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">radius parameters (x-direction) used in the harmonic-oscillator initialization (see subroutine <code>harmosc</code>).  <a href="namespacestatic.html#ad30ae4cf1ce4900bd6dc12ebb31b2d5b">More...</a><br /></td></tr>
<tr class="separator:ad30ae4cf1ce4900bd6dc12ebb31b2d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337a93cb9cb1213411d7e5e9ee020de3"><td class="memItemLeft" align="right" valign="top">real(db)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a337a93cb9cb1213411d7e5e9ee020de3">radiny</a></td></tr>
<tr class="memdesc:a337a93cb9cb1213411d7e5e9ee020de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">radius parameters (y-direction) used in the harmonic-oscillator initialization (see subroutine <code>harmosc</code>).  <a href="namespacestatic.html#a337a93cb9cb1213411d7e5e9ee020de3">More...</a><br /></td></tr>
<tr class="separator:a337a93cb9cb1213411d7e5e9ee020de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecffa108dc9fb276021f14ec6be1ab8d"><td class="memItemLeft" align="right" valign="top">real(db)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#aecffa108dc9fb276021f14ec6be1ab8d">radinz</a></td></tr>
<tr class="memdesc:aecffa108dc9fb276021f14ec6be1ab8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">radius parameters (z-direction) used in the harmonic-oscillator initialization (see subroutine <code>harmosc</code>).  <a href="namespacestatic.html#aecffa108dc9fb276021f14ec6be1ab8d">More...</a><br /></td></tr>
<tr class="separator:aecffa108dc9fb276021f14ec6be1ab8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f397c6a24a7072aec2d2b22df3b0516"><td class="memItemLeft" align="right" valign="top">real(db)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a9f397c6a24a7072aec2d2b22df3b0516">serr</a></td></tr>
<tr class="memdesc:a9f397c6a24a7072aec2d2b22df3b0516"><td class="mdescLeft">&#160;</td><td class="mdescRight">convergence criterion. Iterations are stopped if the fluctuation in single-particle energies falls below this value (see near the end of subroutines {<code>statichf</code>).  <a href="namespacestatic.html#a9f397c6a24a7072aec2d2b22df3b0516">More...</a><br /></td></tr>
<tr class="separator:a9f397c6a24a7072aec2d2b22df3b0516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcc54d2fc7d8da0a476932ae0d56671"><td class="memItemLeft" align="right" valign="top">real(db)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a4bcc54d2fc7d8da0a476932ae0d56671">delesum</a></td></tr>
<tr class="memdesc:a4bcc54d2fc7d8da0a476932ae0d56671"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to sum up the changes in single-particle energies during one iteration; it is calculated in <code>statichf</code> but printed in <code>sinfo</code> so that it is a module variable.  <a href="namespacestatic.html#a4bcc54d2fc7d8da0a476932ae0d56671">More...</a><br /></td></tr>
<tr class="separator:a4bcc54d2fc7d8da0a476932ae0d56671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa3bb53bc9f36f4064876373e806d4b"><td class="memItemLeft" align="right" valign="top">real(db)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#a4fa3bb53bc9f36f4064876373e806d4b">x0dmp</a> =0.2D0</td></tr>
<tr class="memdesc:a4fa3bb53bc9f36f4064876373e806d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">corresponds to the parameter <img class="formulaInl" alt="$ x_0 $" src="form_214.png"/> appearing in the damped gradient iteration.  <a href="namespacestatic.html#a4fa3bb53bc9f36f4064876373e806d4b">More...</a><br /></td></tr>
<tr class="separator:a4fa3bb53bc9f36f4064876373e806d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60f84483bcf8e28fe2132e5ccfedae6"><td class="memItemLeft" align="right" valign="top">real(db)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#ad60f84483bcf8e28fe2132e5ccfedae6">e0dmp</a> =100.D0</td></tr>
<tr class="memdesc:ad60f84483bcf8e28fe2132e5ccfedae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">corresponds to the parameter <img class="formulaInl" alt="$ E_0 $" src="form_66.png"/> appearing in the damped gradient iteration.  <a href="namespacestatic.html#ad60f84483bcf8e28fe2132e5ccfedae6">More...</a><br /></td></tr>
<tr class="separator:ad60f84483bcf8e28fe2132e5ccfedae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac715209896dd2373428688296794408c"><td class="memItemLeft" align="right" valign="top">real(db)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestatic.html#ac715209896dd2373428688296794408c">x0dmpmin</a> =0.2d0</td></tr>
<tr class="memdesc:ac715209896dd2373428688296794408c"><td class="mdescLeft">&#160;</td><td class="mdescRight">corresponds to minimal value of <img class="formulaInl" alt="$ x_0 $" src="form_214.png"/> appearing in the damped gradient iteration, if tvaryx_0 is set to <code>.TRUE.</code>.  <a href="namespacestatic.html#ac715209896dd2373428688296794408c">More...</a><br /></td></tr>
<tr class="separator:ac715209896dd2373428688296794408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This module contains the routines needed for the static iterations. All the logic needed for this case is concentrated here; all other modules except for <code>External</code> are equally used in the dynamic calculation. </p>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="a8fc2fc5ec7d1e7932a73664556b37785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc2fc5ec7d1e7932a73664556b37785">&#9670;&nbsp;</a></span>diagstep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine static::diagstep </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>iq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>nlin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This subroutine performs a diagonalization of the single-particle Hamiltonian using the LAPACK routine <code>ZHEEVD</code>. This is of course done separately for protons and neutrons indexed by <code>iq</code>. The matrix <code>hmatr</code> is produced in <code>grstep</code>. </p>
<p>We do not give excessive detail here but summarize the main points, which should be easy to analyze. The steps are:</p>
<ul>
<li><b>Step 1</b>: the matrix is copied into array <code>unitary</code>. The <code>ZHEEVD</code> is called, which leaves as main results the vector of eigenvalues <code>eigen</code> and the unitary matrix <code>unitary</code> describing the transformation from the original states to the diagonalized ones. The latter matrix is stored in lower-diagonal form.</li>
<li><b>Step 2: transform states</b>: the matrix <code>unitary</code> is used to form the appropriate linear combinations of the original single-particle states. If <code>tlarge</code> is true, each state if formed independently and written onto a scratch file, otherwise an intermediate array <code>ps1</code>, dimensioned to hold either only protons or only neutrons (number of states through the argument <code>nlin</code>), is allocated to receive the new states, which are then copied back into <code>psi</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iq</td><td>INTEGER, takes tisospin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nlin</td><td>INTEGER, takes the number of particles with isospin <code>iq</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0819e22b12fb490f7e3d309592b6b6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0819e22b12fb490f7e3d309592b6b6b7">&#9670;&nbsp;</a></span>getin_static()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine static::getin_static</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine reads the input for the static calculation using namelist <code>static</code>. </p>
<p>This includes the module variables of this module, but also the numbers of particles, which are input quantities only in the static mode if initialization is not done via fragment files. In the case of user initialization they are also needed to correctly allocate the fields; only the wave functions are then calculated in <code>user_init</code>. The values given in the input are overwritten by fragment data otherwise.</p>
<p>Thus only if <code>nof&lt;=0</code> the input numbers are used. If <code>npsi</code> is not given in the input, the values of <code>nneut</code> and <code>nprot</code> are used for the number of wave functions, except for the pairing case, when they are computed from a formula.</p>
<p>The variables <code>charge_number</code> and <code>mass_number</code> are also set for this case. </p>

</div>
</div>
<a id="ac009061bd66f4ecd0ecedfc3195ef394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac009061bd66f4ecd0ecedfc3195ef394">&#9670;&nbsp;</a></span>grstep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine static::grstep </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>nst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>iq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(db), intent(inout)&#160;</td>
          <td class="paramname"><em>spe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(db), intent(out)&#160;</td>
          <td class="paramname"><em>denerg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex(db), dimension(:,:,:,:), intent(inout)&#160;</td>
          <td class="paramname"><em>psin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This subroutine applies the damped gradient step to a wave function <code>psi</code>. Its index is <code>nst</code> and isospin <code>iq</code> - these data are needed for the construction of the Hamiltonian matrix <code>hmatr</code>. The argument <code>spe</code> <img class="formulaInl" alt="$ \rightarrow\epsilon $" src="form_215.png"/> represents the single-particle energy which is used a an energy shift in the calculation. </p>
<p>The work is done in the following steps:</p><ol type="1">
<li>apply <img class="formulaInl" alt="$ \hat h-\epsilon $" src="form_216.png"/> to the wave function <code>psin</code> to obtain <code>ps1</code>.</li>
<li><p class="startli">calculate the diagonal matrix element of <img class="formulaInl" alt="$ \hat h $" src="form_54.png"/> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\tt xnormb}=\langle {\tt psin}|{\tt ps1}\rangle=\langle {\tt psin}|\hat h|{\tt psin}\rangle\]" src="form_217.png"/>
</p>
<p> and the squared norm of <code>psin</code> (in <code>xnorm</code>). The expression <code>xnormb/xnorm</code> thus corresponds to the expectation value <img class="formulaInl" alt="$ \|\hat h\| $" src="form_218.png"/> in <code>psin</code>.</p>
<p class="startli">Then the matrix elements of <img class="formulaInl" alt="$ \hat h $" src="form_54.png"/> with all other states of the same isospin are calculated and inserted into <code>hmatr</code>; in the diagonal matrix elements the energy shift <img class="formulaInl" alt="$ \epsilon $" src="form_219.png"/> is added back.</p>
</li>
<li>for the calculation of the fluctuation in the single-particle energy, the quantity <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\tt exph2}=\langle {\tt psin}|\hat h^2|{\tt psin}\rangle \]" src="form_220.png"/>
</p>
 is used to compute <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\tt sp\_efluct1}=\sqrt{\|\hat h^2\|-\|\hat h\|^2} \]" src="form_221.png"/>
</p>
 and the squared norm <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\tt varh2}=\|\hat h\,{\tt psin}\|^2 \]" src="form_222.png"/>
</p>
 similarly for the second fluctuation measure <p class="formulaDsp">
<img class="formulaDsp" alt="\[ {\tt sp\_efluct2}=\sqrt{\|\hat h\,{\tt psin}\|^2/\|{\tt psin}\|^2-\|\hat h\|^2}. \]" src="form_223.png"/>
</p>
 They are calculated only for time steps with output turned on.</li>
<li>now the damping is performed. We first compute <p class="formulaDsp">
<img class="formulaDsp" alt="\[ |{\tt ps1}\rangle-{\tt xnormb}\,|{\tt psin}\rangle=\left(\hat h -\langle {\tt psin}|\hat h|{\tt psin}\rangle\right)\,|{\tt psin}\rangle \]" src="form_224.png"/>
</p>
 replacing <code>ps1</code>, on which then the real damping operator acts. If <code>FFT</code> is being used for the derivatives, we use the routine <code>laplace</code> from module <code>levels</code> to compute <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{x_{0\rm dmp}}{E_{0\rm inv}+\hat t}\,|{\tt ps1}\rangle. \]" src="form_225.png"/>
</p>
 If derivatives are to done by matrices, the damping matrices <code>cdmpx</code> etc. are used (see subroutine <code>setdmc</code> in module <code>Grids</code>. <br  />
 The factors <code>x0dmp</code> and <code>e0dmp</code> have to be manipulated a bit in this case. Finally we subtract this result multiplied by <code>x0act</code> from the original wave function to get the damped one.</li>
<li>the single-particle energy is calculated from its new expectation value with the energy shift restore, and the comparison with the initial value yields the relative change <code>denerg</code>, which is passed back to the caller.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nst</td><td>INTEGER, takes the index of the wave function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iq</td><td>INTEGER, takes the isospin. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">spe</td><td>REAL(db), takes and returns single-particle energy. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">denerg</td><td>REAL(db), returns the difference in energy of the particle before and after the iteration. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">psin</td><td>REAL(db), array, wave function to be iterated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a567e41f470e7ceb65e1820519b13bf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567e41f470e7ceb65e1820519b13bf5f">&#9670;&nbsp;</a></span>harmosc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine static::harmosc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This subroutine initializes all wave function with harmonic oscillator states. </p>
<p>As a first step it calculates the first state, which is a Gaussian. In the second step the other wave functions are obtained by multiplying the Gaussian with polynomials. The subroutine does not return normalized states. In combination with <code>schmid</code> the normalized lowest oscillator states are obtained. </p>

</div>
</div>
<a id="afa74b74b5f0d14e753aea12e1f5a3015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa74b74b5f0d14e753aea12e1f5a3015">&#9670;&nbsp;</a></span>init_static()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine static::init_static</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This subroutine essentially just prints the static input and then initializes the header files with their header lines. </p>
<p>This is not included in <code>getin_static</code>, because the particle and state numbers may have been changed by fragment input.</p>
<p>In addition, the damping matrices are constructed by calling <code>setup_damping</code>. Finally for some Skyrme forces the effective mass is changed to account for the center-of-mass correction. This should only be used if necessary and not in dynamic calculations. </p>

</div>
</div>
<a id="a4414bd66d5a02faadc9bca95de6630e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4414bd66d5a02faadc9bca95de6630e6">&#9670;&nbsp;</a></span>sinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine static::sinfo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This subroutine computes the data that are not needed for the calculation itself, but only for informative output and writes them onto the appropriate output files. </p>
<p>First <code>moments</code>, <code>integ_energy</code>, and <code>sum_energy</code> are called to compute the relevant physical quantities. Output lines are added to <code>converfile</code>, <code>dipolesfile</code>, <code>momentafile</code>, and <code>spinfile</code>. Information on the current energy <code>ehf</code>, the total kinetic energy <code>tke</code>, the relative change in energy over the last iteration <code>delesum</code>, the fluctuations in single-particle energy, and the energy corrections are printed on standard output.</p>
<p>At intervals of <code>mplot</code> iterations the density printer plot is produced and the <code> *.tdd</code> file containing the densities written.</p>
<p>Finally, on standard output more detailed output is given: an overview of the different contributions to the energy, a list of single-particle state properties, and a listing of various moments using <code>moment_print</code>. </p>

</div>
</div>
<a id="a6429b3a218b0e96282940fa9f8573cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6429b3a218b0e96282940fa9f8573cff">&#9670;&nbsp;</a></span>statichf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine static::statichf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the principal routine for the static iterations. It applies the gradient step repeatedly until convergence is achieved or the maximum number of iterations is reached. </p>
<p>The following local variables are worth defining:</p><ul>
<li><b><code>sumflu</b></code> keeps track of the fluctuations in single-particle energies summed over the states. It is used as the convergence criterion.</li>
<li><b><code>addnew</code>, <code>addco</b></code> are simple factors with standard values 0.2 and 0.8 used for relaxation (see Step 8). They are defined as parameter variables so they can be changed easily if desired.</li>
<li><b><code>denerg</b></code> is used as an argument to <code>grstep</code> to contain the relative change in energy of the single-particle state.</li>
</ul>
<ul>
<li><b> Step 1: Initialization</b>: if this is a restart, the number of the initial iteration is set to the value of <code> iter+1</code> obtained from <code>wffile</code>. In this case the single-particle quantities do not have to be set to zero and orthogonalization is not necessary. If this is not a restart, the initialization is done as zeroth iteration and the first iteration number for the loop is set to one. some variables are initialized to zero and the matrix for the diagonalization <code>hmatr</code> is allocated. Then <code>schmid</code> is called for initial orthogonalization.</li>
<li><b> Step2: calculating densities and mean fields</b>: the densities are reset to zero and then in a loop over states the contributions of the single-particle states are added up. The subroutine <code>skyrme</code> is called to compute the mean-field components.</li>
<li><b> Step 3: initial gradient step</b>: in a loop over the single-particle wave functions the gradient step is applied - see subroutine <code>grstep</code>. The sum of relative changes in single-particle energies and fluctuations are accumulated in <code>delesum</code> and <code>sumflu</code>. This loop is followed by the pairing calculation (which needs the single-particle energies calculated in the gradient step) and renewed orthogonalization. Then the detailed single-particle properties and energies are calculated using <code>sp_properties}</code> and <code>sinfo</code>.</li>
<li><b> Step 4: start iteration</b>: this is the principal loop for the static calculation. The iteration number is printed.</li>
<li><b> Step 5: gradient step</b>: this is identical to the initial gradient step in "Step 3".</li>
<li><b> Step 6: diagonalization</b>: after 20 iterations and only if the switch <code>tdiag</code> is true, <code>diagstep</code> is called to diagonalize the single-particle Hamiltonian.</li>
<li><b> Step 7: pairing and orthogonalization</b>: these are called for the new wave functions.</li>
<li><b> Step 8: calculate densities and fields with relaxation</b>: the old density <code>rho</code> and kinetic energy density <code>tau</code> are saved in <code>upot</code> and <code>bmass</code>, which are here used purely as work arrays. Then the new densities are accumulated from the wave functions and for <code>rho</code> and <code>tau</code> they are mixed with the old densities in a ratio given by <code>addnew</code> and <code>addco</code>, if this is turned on by <code>taddnew</code>. <code>skyrme</code> is called to calculate the new fields. Then the detailed single-particle properties and energies are calculated and printed using <code>sp_properties}</code> and <code>sinfo</code>.</li>
<li><b> Step 9: finalizing the loop</b>: convergence is checked by comparing <code>sumflu</code> per particle to <code>serr</code>, if it is smaller, the job terminates after writing the final wave functions. Otherwise, the wave functions are written if indicated by <code>mrest</code>.</li>
</ul>
<p>and the loop continues. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4bcc54d2fc7d8da0a476932ae0d56671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcc54d2fc7d8da0a476932ae0d56671">&#9670;&nbsp;</a></span>delesum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(db) static::delesum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used to sum up the changes in single-particle energies during one iteration; it is calculated in <code>statichf</code> but printed in <code>sinfo</code> so that it is a module variable. </p>

</div>
</div>
<a id="ad60f84483bcf8e28fe2132e5ccfedae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60f84483bcf8e28fe2132e5ccfedae6">&#9670;&nbsp;</a></span>e0dmp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(db) static::e0dmp =100.D0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>corresponds to the parameter <img class="formulaInl" alt="$ E_0 $" src="form_66.png"/> appearing in the damped gradient iteration. </p>

</div>
</div>
<a id="a0a40f66c0ff0224e36ec56c3ac25e492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a40f66c0ff0224e36ec56c3ac25e492">&#9670;&nbsp;</a></span>maxiter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer static::maxiter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maximum number of iterations allowed. </p>

</div>
</div>
<a id="ad30ae4cf1ce4900bd6dc12ebb31b2d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30ae4cf1ce4900bd6dc12ebb31b2d5b">&#9670;&nbsp;</a></span>radinx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(db) static::radinx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>radius parameters (x-direction) used in the harmonic-oscillator initialization (see subroutine <code>harmosc</code>). </p>

</div>
</div>
<a id="a337a93cb9cb1213411d7e5e9ee020de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337a93cb9cb1213411d7e5e9ee020de3">&#9670;&nbsp;</a></span>radiny</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(db) static::radiny</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>radius parameters (y-direction) used in the harmonic-oscillator initialization (see subroutine <code>harmosc</code>). </p>

</div>
</div>
<a id="aecffa108dc9fb276021f14ec6be1ab8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecffa108dc9fb276021f14ec6be1ab8d">&#9670;&nbsp;</a></span>radinz</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(db) static::radinz</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>radius parameters (z-direction) used in the harmonic-oscillator initialization (see subroutine <code>harmosc</code>). </p>

</div>
</div>
<a id="a9f397c6a24a7072aec2d2b22df3b0516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f397c6a24a7072aec2d2b22df3b0516">&#9670;&nbsp;</a></span>serr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(db) static::serr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convergence criterion. Iterations are stopped if the fluctuation in single-particle energies falls below this value (see near the end of subroutines {<code>statichf</code>). </p>

</div>
</div>
<a id="a02053607d91051521724b6d73caa35e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02053607d91051521724b6d73caa35e4">&#9670;&nbsp;</a></span>tdiag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical static::tdiag =.FALSE.</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if <code>true</code>, there is a diagonalization of the Hamiltonian during the later (after the 20th) static iterations. The 20 is hard coded in <code><a class="el" href="static_8f90.html">static.f90</a></code>. </p>

</div>
</div>
<a id="ae48d61c855e561751a112a5d392a728d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48d61c855e561751a112a5d392a728d">&#9670;&nbsp;</a></span>tlarge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical static::tlarge =.FALSE.</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if <code>true</code>, during the diagonalization the new wave functions are temporarily written on disk to avoid </p>

</div>
</div>
<a id="a0b0a2ff8e5c6872e60c3ed0dfbed39c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0a2ff8e5c6872e60c3ed0dfbed39c4">&#9670;&nbsp;</a></span>tvaryx_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">logical static::tvaryx_0 =.FALSE.</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>it <code>.TRUE.</code> the parameter <img class="formulaInl" alt="$ x_0 $" src="form_214.png"/> is changed in every iteration in order to achieve faster convergence. </p>

</div>
</div>
<a id="a4fa3bb53bc9f36f4064876373e806d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa3bb53bc9f36f4064876373e806d4b">&#9670;&nbsp;</a></span>x0dmp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(db) static::x0dmp =0.2D0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>corresponds to the parameter <img class="formulaInl" alt="$ x_0 $" src="form_214.png"/> appearing in the damped gradient iteration. </p>

</div>
</div>
<a id="ac715209896dd2373428688296794408c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac715209896dd2373428688296794408c">&#9670;&nbsp;</a></span>x0dmpmin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(db) static::x0dmpmin =0.2d0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>corresponds to minimal value of <img class="formulaInl" alt="$ x_0 $" src="form_214.png"/> appearing in the damped gradient iteration, if tvaryx_0 is set to <code>.TRUE.</code>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacestatic.html">static</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
